% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ModifyData.R
\name{normalisePlates}
\alias{normalisePlates}
\title{Normalising culture fitness by plate}
\usage{
normalisePlates(d, column, groupcol = "Treatment", fmin = 1e-06)
}
\arguments{
\item{d}{data.frame. Output from qfa.fit2 for normalization}

\item{column}{String. name of column to normalise (typically the fitness measure or model fit value of interest). See qfa.fit2 and
makeFitness2 help files for descriptions of available culture fitness measures}

\item{groupcol}{String. Name of column labelling group membership of each plate/barcode. Typically this will be the Treatment
or Medium column (or some combination of both if there are more than one treatment and more than one medium within the dataframe d)}

\item{fmin}{Epsilon (very small number greater than zero). Do not scale by dividing fitnesses by a plate-wide median if median is less than fmin}
}
\value{
Vector. The output vector contains the normalised values of the input column. This can be added to the input data.frame or replace the
original values.
}
\description{
Sometimes estimated culture fitnesses vary systematically depending on the plate on which they are inoculated. Agar in individual
plates could come from different batches, and therefore have slightly different levels of nutrients or water. Plates could be inoculated
at different times, and stored at slightly different temperatures for example. Depending on inoculation method, inoculation time specified
may be less accurate for individual plates. Any of these issues could effect simulated fitness slightly. This function allows us to normalise
culture fitnessses across plates to eliminate such effects. It should only really be used for small differences. In order to preserve real
signal, the experimental sources of larger differences should be corrected before analysis instead of by normalising them away.
This normalisation function only works if there are more than one plate in the input data.frame as (of course) otherwise there is no
normalisation between plates possible.
}
\details{
Starting with a data frame describing the output from the qfa.fit function (with optional added columns from the makeFitness function)
normalisePlates finds all unique groups in that data frame, calculates a median value from the indicated column for all plates in a given group
and then normalises the fitnesses of each culture on each plate so that the median fitness on each plate is equal to the median fitness for all
plates in the group. The function returns a vector which can be added to the original data frame or used to over-write the original, raw data.

Typically a "group" will be a description of treatment (e.g. temperature) or of growth medium (e.g. drug added to solid agar) or differenet strains.
}
\examples{
data(qfa.testdata)
#Strip non-experimental edge cultures
qfa.testdata = qfa.testdata[(qfa.testdata$Row!=1) & (qfa.testdata$Col!=1) & (qfa.testdata$Row!=8) & (qfa.testdata$Col!=12),]
# Define which measure of cell density to use
qfa.testdata$Growth = qfa.testdata$Intensity
GmpFit = qfa.fit2(qfa.testdata, inocguess=NULL, detectThresh=0, globalOpt=F, AUCLim=NA, TimeFormat="h", Model="Gmp")
# Construct fitness measures
GmpFit = makeFitness2(GmpFit, AUCLim=NA, plotFitness="no", filename = NA)
#create a mock data.frame with slightly increased MDR values
GmpFit_m = GmpFit
GmpFit_m$MDR = GmpFit_m$MDR + rnorm(length(GmpFit_m$MDR), mean = 0.3, sd = 0.1)
#change barcode of mock data.frame and combine into one
GmpFit_m$Barcode = "Mock"
GmpFit_m = rbind(GmpFit, GmpFit_m)
#Add the normalised values of MDR, indicate that the different treatments are stored within ORF column
GmpFit_m$MDRnorm = normalisePlates(GmpFit_m, "MDR", "ORF")
#create plots
qfaFitnessPlot(GmpFit_m, plotFitness = "MDR")
}
\keyword{qfa.fit2}
